<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
	<title>com.rayrobdod.javaScriptObjectNotation.*</title>
</head>
<body>
	<p>
		Another <a href="http://json.org">Java Script Object Notation</a>
		processing unit; this one acts in a way similar to
		<abbr title="Simple Api for Xml">SAX</abbr>. Can also do
		<a href="http://bsonspec.org/">Binary JSON</a> in a similar way.
	</p>
	<h2>The Simple Method</h2>
	<p>
		The simplest way to use this is to take a String in memory and one
		of the classes in the
		{@code com.rayrobdod.javaScriptObjectNotation.parser.decoders}
		package, and pass the string into one of the decoder's
		"decode(String)" methods. The result will be a Collection object of
		the specified type.
	</p>
	<pre><code>new {@link com.rayrobdod.javaScriptObjectNotation.parser.decoders.ToJavaCollectionJSONDecoder}.decode("[1, 2, 3]");</code></pre>
	<p>
		On the BSON side, given that you're not dealing with a String but a ByteStream:
	</p>
	<pre><code>DataInput di = new DataInputStream(new ByteArrayInputStream(
	{ 0x16, 00, 00, 00, 02, 'h', 'e', 'l', 'l', 'o', 00, 
		06, 00, 00, 00, 'w', 'o', 'r', 'l', 'd', 00, 00 }
));
new {@link com.rayrobdod.binaryJSON.parser.decoders.ToJavaCollectionBSONDecoder}.decode(di);</code></pre>
	<h2>The More Through Explanation</h2>
	<h4>JSONParser and JSONParseListener</h4>
	<p>
		The intended way of working with this is closer to SAX. The main
		class to be aware of is the static-only class {@link
		com.rayrobdod.javaScriptObjectNotation.parser.JSONParser}.
		JSONParser parses the string into events, and notifies a
		{@link com.rayrobdod.javaScriptObjectNotation.parser.JSONParseListener}
		of those events. It is very similar to SAX.
	</p><p>
		The built-in JSONParseListeners and BSONParseListeners vary from finding
		attributes of a JSONObject to making a representation of one.
	</p><p>
		Example of use:
	</p>
	<pre><code>Reader reader = ...;
{@link com.rayrobdod.javaScriptObjectNotation.parser.listeners.GetSize} l = new GetSize;
JSONParser.parse(l, reader);
reader.close();
return l.getCount();</code></pre>
	<h4>JSONDecoder</h4>
	<p>
		A Decoder convert a String into whatever that string represents: 
		Number, String, Boolean, Array, 
		Object, null. the difference between the decoders is how the deserialize
		elements. For example, one will turn
		Arrays into {@link java.util.ArrayList}s and one will turn Arrays
		into {@link scala.collection.immutable.Vector}. Using one of the
		appropriate JSONListeners, of course. But the main thing is that it
		filters the strings into the right object for you. And for the
		recursive JSONListeners.
	</p><p>
		The motiviation behind the decoder is to allow recursion. The Parser
		will only parse one layer of the JSON structure at a time. If a
		ParseListener needs to parse multiple layers <small>Ex:
		{@link com.rayrobdod.javaScriptObjectNotation.parser.listeners.GetArrayElement}
		returns the nth value in an array, which is best if it returns a usable
		representation of that value</small> it will use a JSONDecoder to turn
		the string that the JSONParser gave it into a usable representation.   
	</p>
	<h4>Java Collections</h4>
	<p>
		The {@code com.rayrobdod.javaScriptObjectNotation.javaCollection}
		package contains a set of classes that will wrap a string and implement
		the Java Collections Heirarchy. Probably unsuitable for things that are
		intended to be repeatedly used in memory. In addition, the JSONObject
		doesn't support all Map methods. 
	</p><p>
		The motivation here is that the other JSON libraries tend to have
		<code>JSONArray extends List</code> classes that wrap a List, which
		offended my sensibilities.
	</p><p>
		Basically, if there is a part that doesn't work quite as well as it
		should, this is it.
	</p>
	<h4>JSONContentHandler</h4>
	<p>
		<small>The joys of dogfooding</small>
	</p><p>
		{@link com.rayrobdod.javaScriptObjectNotation.JSONContentHandler}
		implements {@link java.net.ContentHandler} by turning the contents of a
		URLConnection into either a Map or List using JSONParser. This doesn't
		set up the use of the URLConnections.
	</p>
	<h4>JSONWriter</h4>
	<p>
		The short version is "I don't like it; I want something more extensible". Don't expect
		{@link com.rayrobdod.javaScriptObjectNotation.JSONWriter} to remain stable.
	</p><p>
		The main reason this exists is because hand-writing BSON is hard.
	</p>
	<h4>BSON</h4>
	<p>
		The BSON stuff is fairly analogous to the JSON stuff.
		{@code com.rayrobdod.binaryJSON.parser.BSONParser} is similar to 
		{@code com.rayrobdod.javaScriptObjectNotation.parser.JSONParser}. The
		main difference is that BSON uses {@link java.io.DataInput} as the input
		source rather than a {@link java.io.Reader}. And BSON can be parsed in a
		single pass, where JSON cannot.
	</p>
</body>
</html>
