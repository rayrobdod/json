package com.rayrobdod.javaScriptObjectNotation.parser.listeners;

import com.rayrobdod.javaScriptObjectNotation.parser.JSONParseListener;
import com.rayrobdod.javaScriptObjectNotation.parser.JSONParser;
import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.text.ParseException;

/**
 * A JSONParseListener that outputs a string with each item on a new line and indented to match its level
 * @author Raymond Dodge
 * @version Jan 1, 2011
 * @version 15 Dec 2011 - moved from {@code net.verizon.rayrobdod.javaScriptObjectNotation} to {@code com.rayrobdod.javaScriptObjectNotation;}
 * @deprecated - intent may have been taken over by {@link ToScalaTextParseListener} - need to double check this
 * @version 15 Jan 2011 - moved from {@code com.rayrobdod.javaScriptObjectNotation.parser}
		to {@code com.rayrobdod.javaScriptObjectNotation.parser.listeners}
 */
public class JSONIndenter implements JSONParseListener
{
	private final StringBuilder builder;
	private boolean reachedEndBracket;
	private StringBuilder elementBuilder;
	private PipedWriter pipedWriter;
	private Thread pipedThread;
	private JSONIndenter pipedL;
	private final int level;
	
	/**
	 * Creates a JSONIndeter.
	 */
	public JSONIndenter()
	{
		this(1);
	}
	
	/**
	 * Creates a JSONIndenter that indents to the specified level
	 */
	private JSONIndenter(int level)
	{
		builder = new StringBuilder();
		reachedEndBracket = false;
		this.level = level;
	}
	
	public boolean abort()
	{
		return reachedEndBracket;
	}
	
	public void charRead(int index, char character)
			throws IllegalStateException
	{
		if (elementBuilder == null)
		{
			throw new IllegalStateException("chars read outside element");
		}
		else if (pipedWriter != null)
		{
			try
			{
				pipedWriter.write(character);
			}
			catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		else if (elementBuilder.length() == 0)
			// if nothing has been put into the builder yet
		{
			if (character == '[' || character == '{')
			{
				try
				{
					// recursion
					pipedWriter = new PipedWriter();
					PipedReader reader = new PipedReader(pipedWriter);
					pipedWriter.write(character);
					
					pipedL = new JSONIndenter(level + 1);
					
					pipedThread = new Thread(new PipedRunnable(pipedL, reader), "Recursion Condenser Thread");
					// priority down, since that requires input from this to continue
					pipedThread.setPriority(Math.max(Thread.MIN_PRIORITY, Thread.currentThread().getPriority() - 1));
					pipedThread.start();
				}
				catch (IOException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			else if (("" + character).matches("\\s"))
			{
				// do nothing
			}
			else
			{
				elementBuilder.append(character);
			}
		}
		else
		{
			elementBuilder.append(character);
		}
	}

	public void elemEnded(int commaIndex, char character)
			throws IllegalStateException, ParseException
	{
		if (pipedThread == null)
		{
			builder.append(elementBuilder.toString().trim());
		}
		else
		{
			while (pipedThread.isAlive())
			{
				try
				{
					pipedThread.join();
				}
				catch (InterruptedException e)
				{
					// try again
				}
			}
			
			builder.append(pipedL.getString().trim());
		}
		builder.append(character);
		builder.append('\n');
		for (int i = 0; i < level; i++)
		{
			builder.append('\t');
		}
		
		pipedWriter = null;
		elementBuilder = null;
		pipedThread = null;
		pipedL = null;
	}

	public void elemStarted(int commaIndex, char character)
			throws IllegalStateException
	{
		builder.append(character);
		elementBuilder = new StringBuilder();
	}

	public void ended() throws IllegalStateException, ParseException
	{
	}

	public void endingBracket(int index, char character)
			throws IllegalStateException, ParseException
	{
		this.reachedEndBracket = true;
	}

	public void keyValueSeparation(int colonIndex, char character)
			throws IllegalStateException, ParseException, ClassCastException
	{
		builder.append(elementBuilder.toString().trim());
		builder.append(character);
		elementBuilder = new StringBuilder();
	}

	public void openingBracket(int index, char character)
			throws IllegalStateException, ParseException
	{
		builder.append(character);
	}

	public void started() throws IllegalStateException
	{
		builder.delete(0, builder.length());
		reachedEndBracket = false;
	}
	
	/**
	 * returns the string generated by running this though the parser
	 * @return the string generated by running this though the parser
	 */
	public String getString()
	{
		return builder.toString();
	}
	
	private class PipedRunnable implements Runnable
	{
		private final PipedReader reader;
		private final JSONIndenter l;
		
		public PipedRunnable(JSONIndenter pipedL, PipedReader reader)
		{
			this.reader = reader;
			this.l = pipedL;
		}
		
		public void run()
		{
			try
			{
				JSONParser.parse(l, reader);
			}
			catch (NullPointerException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			catch (ParseException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
